<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Narae.js</title>
    <link>https://naraejs.org/ko/</link>
    <description>Recent content on Narae.js</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 04 Dec 2020 21:26:24 +0900</lastBuildDate><atom:link href="https://naraejs.org/ko/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Transaction</title>
      <link>https://naraejs.org/ko/learn/stereotypes/connection_manager/transaction/</link>
      <pubDate>Sun, 20 Dec 2020 02:53:00 +0900</pubDate>
      
      <guid>https://naraejs.org/ko/learn/stereotypes/connection_manager/transaction/</guid>
      <description>@Transaction 어노테이션을 메서드에 적용함으로써 자동화된 Transaction 처리가 가능합니다.
트랜잭션을 지원하려면 ConnectionManager에서 transactional가 true이어야 하며 커넥션에서 ITransactionalConnection을 구현해야 합니다.
반드시 @Transactional 메서드 내에서 getConnection을 호출해야 하며, 중첩된 @Transactional 사용시 트랜잭션이 전파됩니다.
Example:
@Service() class TestService { private _testCM: TestCM; constructor(@Inject(TestCM) testCM: TestCM) { this._testCM = testCM; } @Transactional() public methodB(a: number): Promise&amp;lt;void&amp;gt; { return this._testCM.getConnection() .then((connection) =&amp;gt; { connection.insert(&amp;#39;THIRD&amp;#39;); connection.insert(&amp;#39;FOURTH&amp;#39;); }); } @Transactional() public methodA(a: number): Promise&amp;lt;void&amp;gt; { return this._testCM.getConnection() .then((connection) =&amp;gt; { connection.</description>
    </item>
    
  </channel>
</rss>
